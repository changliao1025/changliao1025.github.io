<p>One of my recent development projects needs to exchange several variables between different components using the Common Infrastructure for Modeling the Earth (<a href="http://esmci.github.io/cime/">CIME</a>) model. However, different components have different grid systems. Therefore, I have to get familiar with the grid system of these two component before assigning any variables.</p>

<p>One of them is the land grid used in Community Land Model (<a href="http://www.cesm.ucar.edu/models/clm/">CLM</a>)/ELM, which is the land component in the Energy Exascale Earth System Model (<a href="https://e3sm.org/">E3SM</a>) model. Because CLM is also part of CESM, this post should also apply to the CESM land component.</p>

<p>In short, the land component distributes all the land units across multiple nodes/cores and each grid cell is run by clump.</p>

<p>Here I developed a small Python utility to illustrate the concept.</p>

<p>First we define a sample problem as follow:</p>

<p>| 
Variable
 | 
Value
 | 
Description
 |
| 
npes
 | 
4
 | 
CPU/Node
 |
| 
clump_pproc 
 | 
10
 | 
Core per CPU
 |
| 
nsegspc 
 | 
2
 | 
Segment per clump
 |
| 
nclumps
 | 
40
 | 
Core count
 |
| 
lni
 | 
20
 | 
Longitude count
 |
| 
lnj
 | 
10
 | 
Latitude count
 |
| 
numg
 | 
85
 | 
Land count
 |</p>

<p>Then we define the global grid and land mask:</p>

<p>Before you start to read the numbers, you need to understand the index system used in E3SM.<br />
Even though Fortran is a <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">column-major</a> language, the E3SM (written in Fortran) stores the global grid using a row-major approach. As a result, global grid index starts from left to right in memory, same as the land mask (Figure 1).</p>

<p>Note that yellow square represent clump index, blue square represent land index, and red square represents global grid index. <img src="/assets/NK5xRYJvo9RsJll8isEANxGUREJvm8rQSW8YuM4LLHByuSW3wIO5bMHW15nzwgP5zqKmXBnKlkv5-O0RQ5iZbcXOI4nszOVLVgzLOaDsibN32vfbo0puI3KqQE9afOQ8LHGEem-4PQG3Ew" alt="" /></p>

<p>Figure 1. The global ID and land ID map.</p>

<p>Similar to global grid, clump/core index starts from left to right across node/processor. For example, clump 1 is located on the first core on processor 1 and clump 2 is located on the first core on processor 2.</p>

<p>Last, we distribute the land grid onto the clumps. All the land grids are allocated to clump in order. In the end, a clump may simulate multiple land grids which are far away in the spatial domain. For example, the clump 1 simulates land grid 1, 41 and 81 (circled in yellow in Figure 1 and 2).</p>

<p><img src="/assets/2GEbYlp4yVj99-6OsZW1B_Dl_NDGlmrCOZRdmtjiE5zAVKo7410r9TLZCVybR-IG6DvtJIobiqj55-iXhr4ZIg58i_TDRNxI5e1vm4W8mNLsw0KUSKl3jkcH1BiE9R9GLD7hkbSfGBNM7g" alt="" /><br />
Figure 2. The processor, clump and land grid decomposition.</p>

<p>The global grid and land grid is connected through the “gdc2glo” variable, which stores what is the land grid index for each clump in order. For example, gdc2glo[1] = 125 means that the 125th global grid is the “second” (index starting from 0) simulated land grid, which is land grid 41.</p>

<p>Let me know if you have any question.</p>

